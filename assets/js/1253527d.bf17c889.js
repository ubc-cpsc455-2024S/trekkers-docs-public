"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5770],{4374:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"trek-gis-study","metadata":{"permalink":"/trekkers-docs-public/blog/trek-gis-study","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-07-10-gis-study.md","source":"@site/blog/2024-07-10-gis-study.md","title":"Choosing the Best Geographic Information System (GIS) for Trek","description":"This blogpost is a modified version of an internal Trek document. You can view the internal document","date":"2024-07-10T00:00:00.000Z","tags":[{"label":"project","permalink":"/trekkers-docs-public/blog/tags/project"},{"label":"maps","permalink":"/trekkers-docs-public/blog/tags/maps"},{"label":"POI","permalink":"/trekkers-docs-public/blog/tags/poi"},{"label":"GIS","permalink":"/trekkers-docs-public/blog/tags/gis"},{"label":"geocoding","permalink":"/trekkers-docs-public/blog/tags/geocoding"},{"label":"routing","permalink":"/trekkers-docs-public/blog/tags/routing"}],"readingTime":4.595,"hasTruncateMarker":false,"authors":[{"name":"Matthew Kang","title":"Developer","url":"https://www.linkedin.com/in/kang-matt/","imageURL":"/trekkers-docs-public/img/matthewkang.jpeg","key":"matthew"}],"frontMatter":{"slug":"trek-gis-study","title":"Choosing the Best Geographic Information System (GIS) for Trek","authors":["matthew"],"tags":["project","maps","POI","GIS","geocoding","routing"]},"unlisted":false,"nextItem":{"title":"Local Deployment and a Glimpse Into Trek\'s CI/CD System","permalink":"/trekkers-docs-public/blog/local-deployment-experiment"}},"content":":::note\\n\\nThis blogpost is a modified version of an internal Trek document. You can view the internal document\\n[here](/files/Trek-Geographic-Information-System.pdf).\\n\\n:::\\n\\nIntegrating **Google Maps** was our original plan at Trek until we realized that the cost of integrating Google Maps would be outside our budget, as well as the budget of anyone deploying Trek.\\n\\nAlthough Google provides its customers with a $200 credit for the use of their APIs, including the Google Maps Platform APIs, once customers exceed the $200 limit, they are faced with potentially thousands of dollars in billing statements.\\n\\nThe truth is, Google holds a monopoly over high-quality geographical information, especially their Places API, which provides the best up-to-date Points of Interest (POI) data. Using Google would be the best move if we could afford to lose the money. Unfortunately, we are not one of those companies that can lose money for a decade before making a profit.\\n\\nFurthermore, Google does not allow its customers to cache or store any of its data (with the exception of place IDs), which means that every time we want to display a place name for the user, we have to call Google\'s API\u2014something we cannot afford.\\n\\nThis blog post goes through the GIS alternatives to Google Maps that we have explored in the process of designing and building Trek.\\n\\n\\n## What is a GIS?\\n\\nA Geographic Information System (GIS) is a powerful tool that allows users to visualize, analyze, and interpret spatial and geographic data. In the context of Trek, a GIS is essential for enhancing the user experience by providing detailed and interactive maps, route planning, and information on places of interest. It integrates various data sources to create a comprehensive view of the trip and the world.\\n\\n**A Geographic Information System (GIS) for Trek should offer the following features or services:**\\n\\n**Maps -** Various visual dynamic maps imagery. Displays maps for \u2018Map View\u2019 and location markers, \u2018Pins\u2019 within the map, and geographic information (longitude and latitude) to provide context when searching for places.\\n\\n**Routes -** Provides routing information in \u2018driving\u2019, \u2018transiting\u2019, \u2018cycling\u2019, or \u2018walking\u2019. Find best routes from place to place in different transportation methods.\\n\\n**Places of Interest (POI) -** Provides information on places and ability to search for places. Gathers and provides place information including place ID (identifiers), name, location, description, address, photo, and reviews.\\n\\n## What makes a GIS Good (for Trek)?\\n\\nGIS can be used in many different applications and use cases. The goal of GIS in Trek is to help meet its functional and non-functional requirements, \\nincluding scalability and future-oriented design. The goal is to explore different GIS options Trek can integrate, while considering the following:\\n\\n**Compliance \u2014** *\u201cAre we complying with GIS\u2019 Terms of Service? Are we stealing data and potentially committing academic misconduct?\u201d*\\n\\n**UI/UX \u2014** *\u201cDoes the UI Look Good?\u201d*\\n\\n**Usability \u2014** *\u201cDoes it provide good usability with sufficient information of places and provide quality search and personalization?\u201d*\\n\\n**Sustainability \u2014** *\u201cWill the system be financially sustainable with the integration costs? Can costs be lowered by caching or storing data?\u201d*\\n\\n**Maintainability \u2014** *\u201cIs the information easily manageable and does not require frequent extensive maintenance on Trek\u2019s end?\u201d*\\n\\n**Dependency \u2014** *\u201cCan we manage our own information without relying on the GIS?  Are we able to migrate from this GIS to another system easily\u201d*\\n\\n## Comparison of GIS API Integrations\\n\\nSome GIS services do not provide all three packages (Maps, Routing, POI). Some GIS services do not allow caching or storage of data. Some GIS services are outside our budget.\\n\\n### Summary\\n\\n| API                  | Maps & Routing     | Places of Interests   | Caching & Storing            | Pricing    | Description                                                             |\\n| -------------------- | ------------------ | --------------------- | ---------------------------- | ---------- | ----------------------------------------------------------------------- |\\n| Google Maps Platform | Best               | Photos, Reviews       | Restrictive                  | High       | Best up-to-date POI information                                         |\\n| FourSquare           | N/A (POI only)     | Photos, Reviews       | Restrictive                  | Medium     | Provides decent POI and places \u2018personalization\u2019; best for tourist POI  |\\n| Mapbox               | Good               | Integrates FourSquare | Restrictive (non-enterprise) | Medium/Low | Alternative to Google Maps. Good UI. OSM-based. Second most popular     |\\n| LocationIQ           | No transit routing | Only GeoCoding        | Allowed                      | Low        | Fully OSM Data packaged as API. Comes with only Geocoding data (no POI) |\\n| MapTiler             | Good               | Basic                 | Client-side                  | Low        |                                                                         |\\n| HERE                 | Good               | Basic                 | 30 days or Response Header   | Low        | No permanent storage of location IDs                                    |\\n| MapQuest             | No transit routing | Basic                 | Restrictive (non-paid)       | Low        |                                                                         |\\n\\n### POI Data: Image, Description, and Reviews Data\\n\\nApart from Google Maps Platform and ForeSquare, OSM-based GIS APIs only provide basic POI data. Some GIS APIs do not provide contact information or opening hours. We can integrate the following technologies to provide end-users with these data:\\n\\n- **Image** \u2013 For landmarks, well-known businesses (e.g. McDonalds), and attractions, use Wikipedia API to fetch images that are shareable for commercial purposes.\\n- **Description** \u2013 For landmarks, well-known businesses (e.g. McDonalds), and attractions, use AI generated descriptions.\\n- **Contact, Hours, and Reviews** \u2013 Use TripAdvisor or Yelp API to link review data, open hours, and contact information. Only load review data if the user clicks on it to limit unnecessary API calls. Yelp allows caching up to 24 hours but has no free tier.\\n- **In-House User-Contributed POI Data System** \u2013 Support an in-house user-contributed POI Data system, where users can upload images, description, and reviews to a place."},{"id":"local-deployment-experiment","metadata":{"permalink":"/trekkers-docs-public/blog/local-deployment-experiment","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-07-06-local-deployment.mdx","source":"@site/blog/2024-07-06-local-deployment.mdx","title":"Local Deployment and a Glimpse Into Trek\'s CI/CD System","description":"One of our goals as the Trekkers was always to be able to have a","date":"2024-07-06T00:00:00.000Z","tags":[{"label":"project","permalink":"/trekkers-docs-public/blog/tags/project"},{"label":"workflow","permalink":"/trekkers-docs-public/blog/tags/workflow"},{"label":"ci/cd","permalink":"/trekkers-docs-public/blog/tags/ci-cd"}],"readingTime":6.495,"hasTruncateMarker":false,"authors":[{"name":"William Xiao","title":"Developer","url":"https://wyfx.ca/","imageURL":"https://wyfx.ca/misc/WX.jpg","key":"william"}],"frontMatter":{"slug":"local-deployment-experiment","title":"Local Deployment and a Glimpse Into Trek\'s CI/CD System","authors":["william"],"tags":["project","workflow","ci/cd"]},"unlisted":false,"prevItem":{"title":"Choosing the Best Geographic Information System (GIS) for Trek","permalink":"/trekkers-docs-public/blog/trek-gis-study"},"nextItem":{"title":"Work In Progress 3","permalink":"/trekkers-docs-public/blog/wip-3"}},"content":"One of our goals as the Trekkers was always to be able to have a\\n**cost-effective** but **performant** deployment of Trek. As someone who\\nself-hosts their own server for their [personal site](https://wyfx.ca), I\\nthought it would be quite suiting to see if our current needs for deployment and\\nCI/CD could be met through repurposing part of self-hosted solution.\\n\\n## My Site\\nAs a little bit of background, my personal site (https://wyfx.ca) was originally\\nstarted as just a way for me to take the Raspberry Pi I had sitting at home and\\nmake it something useful.\\n\\nThe site was developed under Vite, and deployed under a Docker container running\\nnginx. Whenever I have a new version of the site, I build a new version of the\\nDocker container, then manually restart the container.\\n\\nAt Trek, one of our priorities is always knowing about the status of our\\nproduct. Hence, with some of my knowledge on the team, we aimed to leverage that\\nknowledge to develop our own self-hosted solution for development purposes.\\n\\n## Considerations\\nOn the implementation side, moving from a simple statically hosted website to an\\nintegrated solution with our GitHub workflow would not be easy. Our goals for\\nTrek\'s deployment solution would be something that is **integrated with\\nGitHub**, **performant** enough to run on my Raspberry Pi, and **automatic**.\\nThis solution would be key for our CI/CD process and would ensure that we\'d able\\nto quickly iterate on new updates to our codebase.\\n\\n### Security\\nSecurity was especially important to me as we needed a solution that would not\\nexpose my self-hosted server to too much risk, but would still be able to\\nautomatically integrate with GitHub. My home server did not have a publicly\\nexposed SSH port, yet without one we would not be able to upload files to the\\nserver. However, as my main account on the server was an administrator, I did\\nnot want any possible SSH solutions to have full access to the administrator\\naccount.\\n\\n### Performance\\nThe second primary consideration with our design was performance. This includes\\nboth the \\"visible\\" parts of the site (like API and frontend), but also the build\\nprocess from a successful push to GitHub. While we would not have to worry about\\na large amount of users on the development site, we still wanted a solution that\\nwould be performant enough for us to evaluate how the site would behave for\\nproduction deployment in the future. The limited compute power of the Raspberry\\nPi also means that this deployment needs to be as lean as possible.\\n\\n### Maintainability\\nThe last key consideration was maintainability. The development of Trek moves\\nquickly, so our system should be able to adapt to those changes quickly. Without\\na maintainable system, the system could quickly become obsolete - sacrificing\\nvaluable developer time.\\n\\n-----\\n\\nWith all of our considerations in mind, we started the design of the CI/CD system.\\n\\n## Deployment\\nSince I was most familiar with a Docker container setup like my home server, my\\ninitial thoughts were to create another container running on the server at the\\nsame time as my personal site. So the first challenge was coming up with a\\ndeployment that would allow both Docker containers to run at the same time while redirecting\\nto different domains.\\nMy solution to this issue was to use\\n[nginx-proxy](https://github.com/nginx-proxy/nginx-proxy). `nginx-proxy`\\nessentially acts as a reverse proxy that routes to Docker containers by\\nsubdomain. Now, I can start my own website\'s container with an environment\\nvariable `VIRTUAL_HOST=wyfx.ca`, while having Trek on a subdomain like\\n`SUBDOMAIN.wyfx.ca`. To handle HTTPS, I extended my original LetsEncrypt\\ncertificates using\\n[acme-companion](https://github.com/nginx-proxy/acme-companion), which will\\nautomatically generate a new HTTPS certificate for each of my subdomains by\\nspecifying `LETSENCRYPT_HOST=SUBDOMAIN.wyfx.ca`.\\n\\nThe largest decision to make was how to get updates from our GitHub repository.\\nAs I didn\'t want to expose a public SSH port on my home server, I initially\\nthought about a solution that wouldn\'t directly connect the GitHub repository to\\nthe server. Instead, the server could poll for changes on GitHub, and when\\nchanges are detected, the following would occur:\\n1. Pull the changes from GitHub\\n2. Build a new container\\n3. Restart the running container\\n\\nHowever, we did not end up going with this idea for a few reasons:\\n- Unless we polled at a very fast rate, there was still going to be a delay\\n  before we could even detect a change from GitHub\\n- There were concerns with performance from the fact that the Raspberry Pi would\\n  have to do all the building\\n- We would have to create our own scripts to make the polling + building\\n  possible, which would each cost us maintenance time\\n\\nThe solution we ended up using for the frontend was to create a nginx Docker\\ncontainer that is also running a SSH server. Then, to update the frontend, we\\ncould write a GitHub Action to build the frontend, then SSH into the Docker\\ncontainer and replace the static files in the container. This solution was much\\nsimpler, which would make it easier to maintain. It also does not involve\\nconstantly rebuilding the Docker container, as we would be making local updates\\nto its filesystem instead. In addition, having the publicly exposed SSH port be\\ninto a container would gave me some more comfort that any attacks would not be\\nable to immediately access my entire server (though\\n[such](https://nvd.nist.gov/vuln/detail/CVE-2024-21626)\\n[attacks](https://nvd.nist.gov/vuln/detail/CVE-2024-23651)\\n[are](https://nvd.nist.gov/vuln/detail/CVE-2024-23652)\\n[possible](https://nvd.nist.gov/vuln/detail/CVE-2024-23653)).\\n\\n![The frontend workflow](/img/local-deployment/upload-frontend.png)\\n\\nOur GitHub action to build and upload the frontend is included [in the\\nAppendix](#appendix-github-action). It builds our frontend using `npm`, and then\\nuploads it via SCP to the Docker container using\\n[appleboy/scp-action](https://github.com/appleboy/scp-action/). This ended up\\nlooking like the following:\\n```\\nname: Deploy Frontend Dev\\non:\\n  push:\\n    branches:\\n      - \\"project_[0-9]-dev\\"\\njobs:\\n  deploy:\\n    name: Deploy FE Dev\\n    runs-on: ubuntu-latest\\n    concurrency: deploy-group    # optional: ensure only one action runs at a time\\n    \\n    steps:\\n      - name: Checkout\\n        uses: actions/checkout@v4\\n\\n      - name: Build FE\\n        run: |\\n         cd frontend\\n         npm install\\n         npm run build\\n  \\n      - name: Upload to server\\n        uses: appleboy/scp-action@v0.1.7\\n        with:\\n          host: REDACTED\\n          username: REDACTED\\n          password: REDACTED\\n          port: REDACTED\\n          source: \\"frontend/dist/*\\"\\n          target: REDACTED\\n          overwrite: true\\n          strip_components: 2\\n```\\n\\nFor the backend deployment, we built off of the frontend deployment. Our backend\\ndeployment uses [tsc-watch](https://www.npmjs.com/package/tsc-watch) to start up\\nour backend server, and then monitor for file changes. Then, a GitHub action is\\ntriggered whenever a push has been made to our dev branches, uploading the files\\nvia SCP. `tsc-watch` is built to automatically detect those changes and rebuild\\nthe backend dynamically as its files change. To support the communication\\nbetween our frontend and backend, the backend runs under the same nginx server\\nas the frontend. Requests to our API endpoints (e.g. /api/v1/users) would then\\nbe forwarded to the backend server, allowing us to remain under the same\\nsubdomain and avoid spawning too many Docker containers for the server to\\nhandle. To make this happen, our `nginx.conf` includes the following:\\n```\\nserver {\\n    location /socket.io {\\n      proxy_set_header Host $host;\\n      proxy_set_header X-Real-IP $remote_addr;\\n      proxy_pass REDACTED;\\n    }\\n    location / {\\n      root   REDACTED;\\n      index  index.html;\\n      try_files $uri $uri/ /index.html;\\n    }\\n    location /api {\\n      proxy_set_header Host $host;\\n      proxy_set_header X-Real-IP $remote_addr;\\n      proxy_pass REDACTED;\\n    }\\n    error_page   500 502 503 504  /50x.html;\\n    location = /50x.html {\\n      root   /usr/share/nginx/html;\\n    }\\n  }\\n```\\nBy overwriting what happens with the `location /api` line configuration, we are\\nable to redirect requests to go to the backend server rather than still going to\\nthe frontend.\\n\\n## The Future\\nAs Trek continues to develop, our CI/CD system will have to evolve too. One of\\nour upcoming goals for a future sprint is to integrate testing frameworks into\\nboth our frontend and backend. When our backend develops more, we might also\\nfind that the self-hosted server won\'t be powerful enough. However, with our\\nmaintainable and reproducible system, we are well-equipped to handle these\\nfuture challenges with ease."},{"id":"wip-3","metadata":{"permalink":"/trekkers-docs-public/blog/wip-3","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-06-22-wip-3.mdx","source":"@site/blog/2024-06-22-wip-3.mdx","title":"Work In Progress 3","description":"All members of Trekkers are thrilled to share our third work-in-progress update for Trek.","date":"2024-06-22T00:00:00.000Z","tags":[{"label":"WIP","permalink":"/trekkers-docs-public/blog/tags/wip"}],"readingTime":1.56,"hasTruncateMarker":false,"authors":[{"name":"William Xiao","title":"Developer","url":"https://wyfx.ca/","imageURL":"https://wyfx.ca/misc/WX.jpg","key":"william"},{"name":"Justin Lieu","title":"Developer","url":"https://www.linkedin.com/in/justin-lieu/","imageURL":"/trekkers-docs-public/img/justin.jpg","key":"justin"},{"name":"Matthew Kang","title":"Developer","url":"https://www.linkedin.com/in/kang-matt/","imageURL":"/trekkers-docs-public/img/matthewkang.jpeg","key":"matthew"},{"name":"Jacob Zhu","title":"Developer","url":"https://www.linkedin.com/in/jacob-zhu-a70512212","imageURL":"/trekkers-docs-public/img/jacob.jpg","key":"jacob"},{"name":"Kevin Xu","title":"Developer","url":"https://www.linkedin.com/in/kevin-yg-xu/","imageURL":"/trekkers-docs-public/img/kevin.JPG","key":"kevin"}],"frontMatter":{"slug":"wip-3","title":"Work In Progress 3","authors":["william","justin","matthew","jacob","kevin"],"tags":["WIP"]},"unlisted":false,"prevItem":{"title":"Local Deployment and a Glimpse Into Trek\'s CI/CD System","permalink":"/trekkers-docs-public/blog/local-deployment-experiment"},"nextItem":{"title":"A Deep Dive into Trekkers Project Workflow","permalink":"/trekkers-docs-public/blog/project-workflow"}},"content":"All members of Trekkers are thrilled to share our third work-in-progress update for Trek.\\n\\nIn **Progress 3**, we have added Redux to Trek, by thinking of the main type of data we will be storing and about how we would like this data to be \u201cconnected\u201d to our components.\\n\\n## Redux\\n\\nAs mentioned in the introduction, we have begun the integration of Redux into our application.\\n\\n### Default Data and Display on Page\\n\\nHere is the **default data** that we used to initialize our profile settings reducer.\\n\\n<hr />\\n\\n#### Profile Default Data\\n\\n![Profile Default Data](/img/wip-3/initialState.png)\\n\\n<hr />\\n\\nWe hooked up the state to display on our **user profile settings** page\\n\\n<hr />\\n\\n#### User Profile Settings Page (Displaying from Redux Store)\\n\\n![User Profile Settings Page](/img/wip-3/display2.png)\\n\\n<hr />\\n\\n#### Redux Devtools Screenshot of State\\n\\n![Redux Devtools Screenshot](/img/wip-3/display1.png)\\n\\n<hr />\\n\\n### Our 3 minimum actions\\n\\n#### Action #1: addProfileCurrentLocation\\n\\nThis action handles the addition of a \\"current location\\" of a user to their profile.\\n\\nCode:\\n```js\\nexport const addProfileCurrentLocation = (location: string) => ({\\n    type: ADD_PROFILE_CURRENT_LOCATION,\\n    payload: location\\n})\\n```\\n\\n#### Action #2: addProfileInterest and removeProfileInterest\\n\\nThese two actions handles the interests of a user, allowing them to add new interests, and remove old unwanted ones freely.\\n\\nCode:\\n```js\\nexport const addProfileInterest = (interest: string[]) => ({\\n    type: ADD_PROFILE_INTEREST,\\n    payload: interest\\n})\\n\\nexport const removeProfileInterest = (location: string) => ({\\n    type: REMOVE_PROFILE_INTEREST,\\n    payload: interest\\n})\\n```\\n\\n#### Action #3: addProfileSocialAccount\\nThis action handles addition of social media account links (Facebook, Instagram, Twitter, YouTube)\\n\\nCode:\\n```js\\nexport const addProfileSocialAccount = (accountType: SocialMediaAccounts, url: string) => ({\\n    type: ADD_PROFILE_SOCIAL_ACCOUNT,\\n    payload: { accountType, url }\\n});\\n```\\n\\n<hr />\\n\\n#### Of course, we also have many other actions and plan to add more as complexity of the project increases!\\n\\n![Actions.js](/img/wip-3/actions.png)\\n\\n## Other Goals\\n\\nStay tuned for more updates as we continue to refine and enhance Trek!"},{"id":"project-workflow","metadata":{"permalink":"/trekkers-docs-public/blog/project-workflow","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-06-16-project-workflow.mdx","source":"@site/blog/2024-06-16-project-workflow.mdx","title":"A Deep Dive into Trekkers Project Workflow","description":"Our primary organizational goal at Trekkers is to develop software using the best industry practices we learn from workshops, lab assignments, and our project experiences. When building Trek, we aimed to adopt Agile values and principles effectively in our project workflow.","date":"2024-06-16T00:00:00.000Z","tags":[{"label":"project","permalink":"/trekkers-docs-public/blog/tags/project"},{"label":"workflow","permalink":"/trekkers-docs-public/blog/tags/workflow"},{"label":"project managment","permalink":"/trekkers-docs-public/blog/tags/project-managment"},{"label":"agile","permalink":"/trekkers-docs-public/blog/tags/agile"}],"readingTime":5.61,"hasTruncateMarker":false,"authors":[{"name":"Matthew Kang","title":"Developer","url":"https://www.linkedin.com/in/kang-matt/","imageURL":"/trekkers-docs-public/img/matthewkang.jpeg","key":"matthew"}],"frontMatter":{"slug":"project-workflow","title":"A Deep Dive into Trekkers Project Workflow","authors":["matthew"],"tags":["project","workflow","project managment","agile"]},"unlisted":false,"prevItem":{"title":"Work In Progress 3","permalink":"/trekkers-docs-public/blog/wip-3"},"nextItem":{"title":"Work In Progress 2","permalink":"/trekkers-docs-public/blog/wip-2"}},"content":"Our primary organizational goal at **Trekkers** is to develop software using the best industry practices we learn from workshops, lab assignments, and our project experiences. When building Trek, we aimed to adopt Agile values and principles effectively in our project workflow.\\n\\nThe CPSC 455 course, titled _\\"Applied Industry Practices,\\"_ emphasizes industry practices. However, being Agile is not about merely adopting the most popular industry practices but about embracing practices that support our principles and values. Simply following the most popular \\"Agile\\" practices doesn\'t make us an Agile development team. We strive to be more than just another shop that claims to be Agile.\\n\\n> ***[Manifesto for Agile Software Development:](https://agilemanifesto.org/)***\\n> - **Individuals and interactions** over processes and tools\\n> - **Working software** over comprehensive documentation\\n> - **Customer collaboration** over contract negotiation\\n> - **Responding to change** over following a plan\\n\\n\\nIn our development journey, we have chosen to follow Agile principles because they align with our commitment to continuous improvement, collaboration, and delivering value to our users. Our adaptation of Scrum reflects our dedication to these principles, the **[Trekkers Code](/docs/terms-of-reference#trekkers-code-code-of-conduct)**, and our desire to create an effective and efficient workflow that supports our project goals.\\n\\n## Our Version of Scrum\\n\\nOur version of Scrum aims to be as Agile as possible while meeting all project requirements and learning objectives.\\n\\n### Weekly Sprint Schedule\\n\\nIndividual (non-Trekkers) Course Assignments and Deadlines are _italicized_\\n\\n| Day | Schedule |\\n|-----------------|-------------|\\n| **Sunday** | **Start of Sprint Meeting @ 10:00 AM**<br />**Bi-weekly Formal Scrum due @ 10:00 pm** |\\n| **Monday** | _Bi-Weekly Individual Assignments Due @ 10:00 PM_ |\\n| **Tuesday** |             |\\n| **Wednesday** |             |\\n| **Thursday** | **Mid-Sprint Check-in Meeting @ 5:00 PM**<br />Planning for next sprint or WIP Progress presentation. |\\n| **Friday** | _Bi-Weekly Individual Workshop Survey Due on 11:59 PM_ |\\n| **Saturday** | **End of Sprint (Push @ 10:00 AM)**<br />**Sprint Review:** Read other members\' scrum reports. |\\n\\n* Our sprint begins on **Sunday @ 10:00 AM** and ends on **Saturday @ 10:00 AM**.\\n* During the _**Start of Sprint Meeting**_ we review our scrum report (Sprint Review) on what we have accomplished in the past sprint, and formalize new sprint goals.\\n* During the _**Mid-Sprint Check-in Meeting**_ (happens during Labs), we do a brief check-in on the progress of our sprints.\\n  * Based on our progress, we do some planning for what we should do on the next sprint\\n  * On weeks where there are **Workshop Presentations**, we do planning for presentations, writing documentations, etc.\\n* **Every Saturday @ 10:00 AM** is the **End of Sprint**. Everything should be pushed by then.\\n  * By noon, every completed issues that have not been closed yet should be closed.\\n  * By noon, everyone should complete a very brief scrum report. We use these weekly internal scrum reports for bi-weekly external (submittable) scrum reports.\\n\\n### Meeting Agenda Template\\n\\nOur Scrum meetings are structured on agile principles of communication, interaction, and collaboration. We have structured a meeting agenda **flexible** template that lets us stay focused on reviewing sprints and internal demos, while letting us plan for our next sprint.\\n\\nOur meeting agenda template exists as a GitHub issues template (screenshots below).\\n\\n![Issue Template](/img/project-workflow/issue-template.png)\\n![Issue Template 2](/img/project-workflow/issue-template-2.png)\\n\\n### GitHub Issues for Project Management\\n\\nWe decided **not** to use GitHub Projects because we couldn\'t adjust the visibility settings of the project board. We wanted to create a collaborative environment where team members could actively update their progress without it being publicly visible to other classmates.\\n\\nInstead, we are using GitHub Issues as our main platform for project management. Our belief is that with effective scrum meetings, the utilization of GitHub Issues can facilitate clear communication and tracking of tasks and promote Agility. Here\'s how we leverage GitHub Issues in our workflow:\\n\\n#### Creating Issues\\n\\nMostly after each scrum meeting, every task, bug, or feature is logged as an issue. This ensures that all work items are tracked and nothing is missed.\\nIssues are tagged with appropriate labels (e.g., frontend, backend, bug, documentation) to categorize and prioritize them effectively.\\n\\n#### Assigning Issues\\n\\nDuring the scrum meetings, each issue is assigned to a specific team member based on their expertise and current workload.\\nWe use GitHub\'s assignee feature to make sure responsibilities are clear.\\n\\n#### Tracking Progress:\\n\\nIssues are updated regularly with comments and status updates. We use Discord as our primary platform for communication, including discussions of issues. Our Discord consists of channels for each type of work (frontend, backend, documentation, etc). We associate branches with issues using GitHub\'s branch linking feature, which makes peer-review easier.\\n\\n#### Sprint Planning and Closing Issues\\n\\nAt the start of each sprint, we create, review, and prioritize issues. High-priority tasks are marked with the \\"PRIORITY\\" tag. During the End of Sprint, we review all closed issues. We use the scrum meeting agenda (as an issue), where we link the closed issues for discussions.\\n\\n\\n## Continuous Integration and Deployment\\n\\nTo ensure the quality and stability of our software, we have set up continuous integration and deployment (CI/CD) pipelines:\\n\\n### Automated Testing\\n\\nEvery push to the repository\'s \\"progress\\" branch triggers automated tests. This helps us catch issues early in the development cycle.\\nWe aim to maintain a high code coverage to ensure the robustness of our application.\\n\\n### Code Reviews\\n\\nAll code changes are submitted through pull requests (PRs). PRs must pass automated tests and be reviewed by at least one other team member before being merged. This practice helps us maintain code quality and fosters knowledge sharing within the team.\\n\\n### Continuous Deployment\\n\\nOnce a PR is approved and merged, our CI/CD pipeline automatically deploys the latest code to our private staging environment.\\nWe perform final checks in the staging environment before promoting changes to the released demo environment along with release notes published on our website.\\n\\n## Our Workflow is Evolving\\n\\nBy adhering to Agile principles and customizing our workflow to fit our team\'s needs, we strive to deliver high-quality software efficiently. Our structured yet flexible approach to Scrum, combined with the effective use of GitHub Issues and CI/CD pipelines, enables us to stay organized, collaborative, and adaptive. We continuously seek to improve our processes and deliver value through iterative development and frequent feedback during scrum meetings and workshop design reviews.\\n\\nOur workflow is constantly evolving as we learn and adapt. We are committed to refining our practices, incorporating new insights, and staying responsive to the changing needs of our project and team. This continuous evolution helps us stay agile and ensures that we can meet our goals effectively.\\n\\nWe hope that our detailed project workflow provides insight into how we manage our development process and can serve as our own reference for our future development journeys."},{"id":"wip-2","metadata":{"permalink":"/trekkers-docs-public/blog/wip-2","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-06-08-wip-2.mdx","source":"@site/blog/2024-06-08-wip-2.mdx","title":"Work In Progress 2","description":"All members of Trekkers are thrilled to share our second work-in-progress update and introduce the first pre-release (v0.1.0) of Trek.","date":"2024-06-08T00:00:00.000Z","tags":[{"label":"WIP","permalink":"/trekkers-docs-public/blog/tags/wip"}],"readingTime":1.74,"hasTruncateMarker":false,"authors":[{"name":"William Xiao","title":"Developer","url":"https://wyfx.ca/","imageURL":"https://wyfx.ca/misc/WX.jpg","key":"william"},{"name":"Justin Lieu","title":"Developer","url":"https://www.linkedin.com/in/justin-lieu/","imageURL":"/trekkers-docs-public/img/justin.jpg","key":"justin"},{"name":"Matthew Kang","title":"Developer","url":"https://www.linkedin.com/in/kang-matt/","imageURL":"/trekkers-docs-public/img/matthewkang.jpeg","key":"matthew"},{"name":"Jacob Zhu","title":"Developer","url":"https://www.linkedin.com/in/jacob-zhu-a70512212","imageURL":"/trekkers-docs-public/img/jacob.jpg","key":"jacob"},{"name":"Kevin Xu","title":"Developer","url":"https://www.linkedin.com/in/kevin-yg-xu/","imageURL":"/trekkers-docs-public/img/kevin.JPG","key":"kevin"}],"frontMatter":{"slug":"wip-2","title":"Work In Progress 2","authors":["william","justin","matthew","jacob","kevin"],"tags":["WIP"]},"unlisted":false,"prevItem":{"title":"A Deep Dive into Trekkers Project Workflow","permalink":"/trekkers-docs-public/blog/project-workflow"}},"content":"All members of Trekkers are thrilled to share our second work-in-progress update and introduce the first pre-release (v0.1.0) of Trek.\\n\\nIn **Progress 2**, we have finalized our app structure, including the high-level React component structure, and developed front-end interfaces for the main features of our minimal viable product (MVP).\\n\\n### High-Level Overview\\n\\nThe pages of our web application are categorized into three main groups:\\n- **Main Pages**: Landing Page, Public Profile Page, etc.\\n- **Trip App Pages**: Overview, Details, Analytics Pages\\n- **Settings Pages**: User Profile/Account Settings Page\\n\\nEach of these pages consists of various sub-components. For Progress 2, we have developed some of these core pages and their sub-components that define our MVP.\\n\\n## Tech Stack\\n\\n### TypeScript\\nWe chose React with TypeScript for this phase. TypeScript offers type safety, is an industry standard, and all Trekkers members have experience working with it.\\n\\n### Tailwind CSS\\nWe integrated Tailwind CSS for easier and faster development of styled components. Justin Lieu has led the team in implementing Tailwind during the development process.\\n\\n### Mantine UI\\nWe also utilized Mantine, a popular React UI Component library. After comparing MUI, Chakra, and Mantine, we chose Mantine for its diverse components and ease of customization.\\n\\n## Key Pages and Features\\n\\n### Landing Page\\n\\n![Landing Page 1](/img/wip-2/landing-page-1.png)\\n![Landing Page 2](/img/wip-2/landing-page-2.png)\\n![Responsive 2](/img/wip-2/responsive-2.png)\\n![Profile Dropdown](/img/wip-2/profile-dropdown.png)\\n\\nOur landing page provides a brief description of the application, includes short card components related to travel, and features a newsletter signup.\\n\\n### Profile Page\\n\\n![Profile Page](/img/wip-2/profile-page.png)\\n![Small Trip Cards](/img/wip-2/small-trip-cards.png)\\n![Large Trip Cards](/img/wip-2/large-trip-cards.png)\\n\\nAs mentioned in Progress 1, the profile page displays all trips associated with a user, allowing them to browse through their trips conveniently.\\n\\n### Trip Planning Page\\n\\nThe Trip Planning page is one of the main features of our application, consisting of four subpages: Overview, Details, Map, and Timeline.\\n\\n![Map](/img/wip-2/map.png)\\n![To-do List](/img/wip-2/to-do-list.png)\\n![Trip Details](/img/wip-2/trip-details.png)\\n\\n\\n### Settings Page\\n\\n![Account Settings](/img/wip-2/account-settings.png)\\n![Responsive 1](/img/wip-2/responsive-1.png)\\n![Profile Settings](/img/wip-2/profile-settings.png)\\n\\nThe Settings page includes Account Settings and Public Profile Settings, enabling users to manage their profiles and account preferences.\\n\\nStay tuned for more updates as we continue to refine and enhance Trek!"}]}}')}}]);